"""
Genetic Algorithm for creating genomes
of genetic algorithm PD players
Authors: Grady Bosanko
Version: Fall 2024
"""
import numpy as np
from pd_game import PDGame
from pd_player import PDPlayer
from pattern_player import PatternPlayer
from ga_player import GAPlayer
from simple_player import SimplePlayer
from data_utils import * 

def copy_genome(in_gene):
  return in_gene[:]

def mutate(genome, mut_prob):
  '''
  given a genome (a string)
  mutate each locus with probability mut_prob 

  return: a new genome
  '''
  genome_copy = list(copy_genome(genome))
  for gene in range(len(genome_copy)):
    roll = np.random.rand()
    if roll < mut_prob:
      if np.random.randint(0,2) == 0:
        genome_copy[gene] = 'C'
      else:
        genome_copy[gene] = 'D'

  return ''.join(genome_copy)


def random_bit_string(in_size):
  '''
  generate a string containing 'C' and 'D'
  of specified size
  '''
  genome_list = ['C' if probability(0.5) else 'D' for _ in range(0,in_size)]
  genome_str = ''.join(genome_list)
  return genome_str

def crossover(p1,p2):
  '''
  given two genomes of equal length, picks a random pivot point
  and crosses over the genomes at that pivot point
  returning the two resulting children
  '''
  assert len(p1) == len(p2), "genomes not the same length"
  locus = np.random.randint(0, len(p1))
  p1_a = p1[:locus]
  p1_b = p1[locus:]
  p2_a = p2[:locus]
  p2_b = p2[locus:]

  c1 = p1_a + p2_b
  c2 = p2_a + p1_b

  return (c1,c2)

def two_point_crossover(p1, p2):
  '''
  given two genomes of equal length, picks two random pivot points
  and crosses over the middle slices at those pivot points
  returning the two resulting children
  '''
  assert len(p1) == len(p2), "genomes not the same length"
  locus_a = np.random.randint(0, len(p1))
  locus_b = np.random.randint(0, len(p1))
  while locus_b == locus_a:
    locus_b = np.random.randint(0, len(p1))
  if locus_a > locus_b:
    temp = locus_a
    locus_a = locus_b
    locus_b = temp
  p1_s = p1[:locus_a]
  p1_m = p1[locus_a:locus_b]
  p1_e = p1[locus_b:]
  p2_s = p2[:locus_a]
  p2_m = p2[locus_a:locus_b]
  p2_e = p2[locus_b:]

  c1 = p1_s + p2_m + p1_e
  c2 = p2_s + p1_m + p2_e

  return (c1,c2)

def uniform_crossover(p1, p2):
  '''
  given two genomes of equal length, randomly crosses values
  over between each parent to create children containing only
  parent DNA, but randomly selected from a parent at each locus
  '''
  assert len(p1) == len(p2), "genomes not the same length"
  c1 = ""
  c2 = ""
  for locus in range(len(p1)):
    roll = np.random.randint(0,2)
    if roll == 0:
      c1 += p1[locus]
      c2 += p2[locus]
    else:
      c1 += p2[locus]
      c2 += p1[locus]

  return (c1,c2)


def sort_pop(p):
  '''
  sort the population, p, from most to least fit
  presuming that p is a list of tuples of the form
  (fitness,genome)
  '''
  #using different functions to sort lists is kind of cool
  p.sort(key = lambda x: x[0],reverse=True)
  return p

def make_roulette(pop):
  '''
  Use the prefix_scan (cumulative sum) algorithm
  to come up with a set of roulette wheel slots
  any individual's chance of being selected is
  their fitness/ sum of all fitnesses
  '''
  #sort  pop
  pop = sort_pop(pop) 
  # gets fitnesses out
  fits = np.array([p[0] for p in pop])
  #gets genes out
  genes = [p[1] for p in pop]
  #divides every fitness by sum of all fitnesses
  fits = fits/sum(fits)
  # calculates prefix sum
  #cumulative prefix sum is my favorite algorithm
  prefix_sum = np.cumsum(fits)
  # zips prefixes and genes back together to return
  return list(zip(prefix_sum,genes))

def pick_from_roulette(wheel):
  '''
  Given a roulette wheel generated by make_roulette
  returns an individual from that wheel.
  '''
  prob = np.random.uniform()
  for p,g in wheel:
    if prob <= p:
      return g
  return None

def fitness_games(player):
  '''
  Given genome competes against a few preset patterns
  as well as a simple AI opponent. 
  '''
  total_score = 0
  rounds = 151
  patterns = ["DDCC", "DC", "DCC"]
  pat_player = PDPlayer(PatternPlayer(""))
  game = PDGame(player, pat_player, rounds)
  for pattern in patterns:
    pat_player.type.set_pattern(pattern)
    game.play()
    scores = game.get_scores()
    total_score += scores[0]
  
  ai_player = PDPlayer(SimplePlayer())
  game.change_player(2, ai_player)
  game.play()
  scores = game.get_scores()
  total_score += scores[0]*len(patterns)

  avg_score = total_score/(len(patterns)*2)
  return avg_score

def get_index_of_gene(pop,g):
  '''
  return index of a given gene in the population
  return None and error if the gene isn't in the population
  a helper function.
  '''
  for index, cur_g_tup in enumerate(pop):
    if cur_g_tup[1] == g:
      return index
  print("error - g not in pop")
  return None

def run_ga(max_gens, pop_size, gene_length, mut_prob, xover_rate, xover_fcn, num_elites, fit_fun):
  '''
  Write your description of your GA here.
  max_gens: max number of generations to run
  pop_size: max size of population
  gene_length: how long the genome is
  mut_prob: the mutation probability
  num_elites: number of top parents to keep every gen. 
  fit_fun: the fitness function to use (yes you can pass funs as arguments!)

  '''
  best_fits = []
  #create pop_size random genomes
  genes = [random_bit_string(gene_length) for _ in range(0,pop_size)]
  #evaluate fitness of every genome
  fits = [fit_fun(PDPlayer(GAPlayer(g))) for g in genes]
  #zip them together into tuples
  pop = list(zip(fits,genes))

  gens = 0

  while gens <  max_gens:
    #make new pop
    new_pop = []
    #make wheel (this also sorts pop)
    wheel = make_roulette(pop)
    best_fits.append(pop[0][0])
    #make new population
    elite_index = 0
    while elite_index < num_elites:
      new_pop.append(pop[elite_index])
      elite_index += 1
    while len(new_pop) < len(pop):
      #pick a parent
      p1 = pick_from_roulette(wheel)
      p2 = p1
      while p1 is p2:
        p2 = pick_from_roulette(wheel)

      p1_index = get_index_of_gene(pop,p1)
      p2_index = get_index_of_gene(pop,p2)
      _,p1_Gene = pop[p1_index]
      _,p2_Gene = pop[p2_index]

      if probability(xover_rate):
        c1,c2 = xover_fcn(p1_Gene,p2_Gene)
      else:
        c1,c2 = copy_genome(p1_Gene),copy_genome(p2_Gene)
      #mutate child
      c1 = mutate(c1,mut_prob)
      c2 = mutate(c2,mut_prob)
      #add mutant to new population
      new_pop.append((fit_fun(PDPlayer(GAPlayer(c1))),c1))
      new_pop.append((fit_fun(PDPlayer(GAPlayer(c2))),c2))
    #replace old pop with new pop
    pop = new_pop
    gens +=1
  return best_fits


def run_n_times(max_gens,pop_size, gene_length, mut_prob,xover_rate,xover_fcn,num_elites, fitness_sin, n_runs):
  '''
  Run the genetic algorithm n_runs times
  with given parameters.
  '''
  all_fits = []
  for _ in range(n_runs):
    fits = run_ga(max_gens,pop_size, gene_length, mut_prob,xover_rate,xover_fcn,num_elites, fitness_sin)
    all_fits.append(fits)
  return all_fits
  

if __name__ == "__main__":
  pop_size = 10
  fits = run_ga(10,pop_size,  10, 0.1,0.2,two_point_crossover,int(pop_size*0.2), fitness_games)
  print(fits)
  #plot(fits)
#Run_PBRMHC(10,10,10,0.1,Fitness_Sin)



